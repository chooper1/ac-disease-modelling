#index_R=which(regions_R==region_name, arr.ind=TRUE)
#cases_R=as.integer(R_data[5:nrow(R_data), index_R])
#cases_R=cases_R[!is.na(cases_R)]
#cases_R=c(cases_R[start:length(cases_R)])
#cases_R=rollmean(cases_R, roll_size)
#active_cases=cases_C-(cases_R+cases_F)
S0=c(S=pop, E=0, L=0, I_1=0, I_2=cases_C[1], I_3=0, I_4=0, R_1=0, R_2=0, F_=cases_F[1])
N=pop
if(beta_type=="different"){
par=c(beta_l=0.1, beta_1=0.1, beta_2=0.1)
}
else if(beta_type=="equal"){
par=c(beta=0.38)
} else if(beta_type=="time-dep"){
#par=c(beta_b=0.38, beta_a=0.38, rho=0.55)
par=c(beta_b=0.38, beta_a=0.38)
}
#scale on parameters is different depending on how many pars there are - fix this!
#ODE_fit=optim(par=par, fn=ssq_SEIR, region=region, active_cases=active_cases, cases_F=cases_F, cases_R=cases_R, mu_IFR=mu_IFR, phi=phi, times=times, start=start, fit=fit, S0=S0, pop=pop, control=list(parscale=c(1,1, 1, 1, 1)))
# ODE_fit=optim(par=par, fn=ssq_SEIR, gr=NULL, region=region, cases_C=cases_C, cases_F=cases_F, cases_R=cases_R, mu_IFR=mu_IFR, phi=phi, times=times, start=start, fit=fit, S0=S0, pop=pop, N=N, beta_type=beta_type, intervention=intervention, mu_CFR=mu_CFR, method="L-BFGS-B", lower=c(0, 0), upper=c(1, 1))
ODE_fit=optim(par=par, fn=ssq_SEIR, gr=NULL, region=region, cases_C=cases_C, cases_F=cases_F, cases_R=cases_R, mu_IFR=mu_IFR, phi=phi, times=times, start=start, fit=fit, S0=S0, pop=pop, N=N, beta_type=beta_type, intervention=intervention, mu_CFR=mu_CFR)
fit_par=ODE_fit$par
return(fit_par)
}
#compartment is "A" (active cases), "F" (deaths), or "R" (recovered)
#fit_param is output from fit_to_SEIR. If no parameters are passed, fit_to_SEIR will run
plot_SEIR_fit=function(region, C_data=JHU_C_data, F_data=JHU_F_data, R_data=JHU_R_data, mu_IFR=0.01, pop, beta_type="time-dep",fit_par=NULL, compartment, roll_size=1, intervention=NULL){
if(is.null(fit_par)==TRUE){
fit_par=fit_to_SEIR(region, C_data, F_data, R_data, mu_IFR, pop, beta_type, roll_size=roll_size, intervention=intervention)
}
region_name=regions(C_data)[region]
phi=phi_vs_time(region, C_data, F_data, mu_IFR)
tau_mu_CFR=fit_tau_mu_CFR(region, C_data, F_data)
tau=tau_mu_CFR[1]
mu_CFR=tau_mu_CFR[2]
phi$times=phi$times-tau
times=phi$times
#start=times[1]
fit=lm(ratios~poly(times, 4, raw=TRUE), data=phi)
cases_C=as.integer(C_data[5:nrow(C_data), region])
cases_C=cases_C[!is.na(cases_C)]
start=min(which(cases_C>0, arr.ind=TRUE))
times=c(start:length(cases_C))
cases_C=c(cases_C[start:length(cases_C)])
cases_C=rollmean(cases_C, roll_size)
times=rollmean(times, roll_size)
C_df=data.frame(times, cases_C)
cases_F=as.integer(F_data[5:nrow(F_data), region])
cases_F=cases_F[!is.na(cases_F)]
cases_F=c(cases_F[start:length(cases_F)])
cases_F=rollmean(cases_F, roll_size)
F_df=data.frame(times, cases_F)
regions_R=regions(R_data)
index_R=which(regions_R==region_name, arr.ind=TRUE)
cases_R=as.integer(R_data[5:nrow(R_data), index_R])
cases_R=cases_R[!is.na(cases_R)]
cases_R=c(cases_R[start:length(cases_R)])
cases_R=rollmean(cases_R, roll_size)
R_df=data.frame(times, cases_R)
# active_cases=cases_C-(cases_R+cases_F)
#active_cases_df=data.frame(times, active_cases)
S0=c(S=pop, E=0, L=0, I_1=0, I_2=cases_C[1], I_3=0, I_4=0, R_1=0, R_2=0, F_=cases_F[1])
N=pop
if(beta_type=="different"){
names=c("beta_l", "beta_1", "beta_2", "rho", "a", "kappa", "eta", "mu_E", "mu_2")
fit_par=c(fit_par[1], fit_par[2], fit_par[3], rho=1-mu_CFR, a=1,
kappa=1/1.2, eta=1/8, mu_E=1/4, mu_2=1/5)
names(fit_par)=names
} else if(beta_type=="equal"){
names=c("beta", "rho", "a", "kappa", "eta", "mu_E", "mu_2")
fit_par=c(fit_par[1], rho=1-mu_CFR, a=1, kappa=1/1.2, eta=1/8, mu_E=1/4, mu_2=1/5)
names(fit_par)=names
} else if(beta_type=="time-dep"){
names=c("beta_b", "beta_a", "rho", "a", "kappa", "eta", "mu_E", "mu_2")
fit_par=c(fit_par[1], fit_par[2], rho=1-mu_CFR, a=1, kappa=1/1.2, eta=1/8, mu_E=1/4, mu_2=1/5)
names(fit_par)=names  }
ode_soln=ode(y=S0, times, func=rhs_SEIR, par=fit_par, fit=fit, N=N, phi=phi, beta_type=beta_type, intervention=intervention)
I_2=ode_soln[,"I_2"]
I_4=ode_soln[,"I_4"]
R_2=ode_soln[,"R_2"]
F_=ode_soln[,"F_"]
sim_cases_C=I_2+I_4+R_2+F_
sim_C_df=data.frame(times, sim_cases_C)
sim_F_df=data.frame(times, F_)
sim_R_df=data.frame(times, R_2)
if(compartment=="C"){
plot=ggplot(data=C_df, aes(x=times, y=cases_C))+geom_point()+geom_line(data=sim_C_df, aes(x=times, y=sim_cases_C))+labs(title=region_name)
print(plot)
}
else if(compartment=="F"){
plot=ggplot(data=F_df, aes(x=times, y=cases_F))+geom_point()+geom_line(data=sim_F_df, aes(x=times, y=F_))+labs(title=region_name)
print(plot)
}
else if(compartment=="R"){
plot=ggplot(data=R_df, aes(x=times, y=cases_R))+geom_point()+geom_line(data=sim_R_df, aes(x=times, y=R_2))+labs(title=region_name)
print(plot)
}
}
R0_model=function(region, C_data=JHU_C_data, F_data=JHU_F_data, mu_IFR=0.01, fit_par=NULL, beta_type="time-dep", intervention=NULL){
if(is.null(fit_par)==TRUE){
fit_par=fit_to_SEIR(region, C_data, F_data, R_data, mu_IFR, pop, beta_type, roll_size=roll_size, intervention=intervention)
}
tau_mu_CFR=fit_tau_mu_CFR(region, C_data, F_data)
mu_CFR=tau_mu_CFR[2]
phi=phi_vs_time(region, C_data, F_data, mu_IFR)
phi=mean(phi$ratios)
if(beta_type=="different"){
names=c("beta_l", "beta_1", "beta_2", "rho", "a", "kappa", "eta", "mu_E", "mu_2", "phi")
fit_par=c(fit_par[1], fit_par[2], fit_par[3], rho=1-mu_CFR, a=1,
kappa=1/1.2, eta=1/8, mu_E=1/4, mu_2=1/5, phi=phi)
names(fit_par)=names
} else if(beta_type=="equal"){
names=c("beta_l", "beta_1", "beta_2", "rho", "a", "kappa", "eta", "mu_E", "mu_2", "phi")
fit_par=c(fit_par[1], fit_par[1], fit_par[1], rho=1-mu_CFR, a=1, kappa=1/1.2, eta=1/8, mu_E=1/4, mu_2=1/5, phi=phi)
names(fit_par)=names
} else if(beta_type=="time-dep"){
names=c("beta_l", "beta_1", "beta_2", "rho", "a", "kappa", "eta", "mu_E", "mu_2", "phi")
fit_par=c(fit_par[1], fit_par[1], fit_par[1], rho=1-mu_CFR, a=1, kappa=1/1.2, eta=1/8, mu_E=1/4, mu_2=1/5, phi=phi)
names(fit_par)=names  }
with(as.list(fit_par), {
R0=beta_l/kappa+beta_2/(phi*mu_2)+(1-1/phi)*beta_1/(mu_2+eta)
list(R0)
})
}
#right now only set up to work for
Rt_model=function(region, C_data=JHU_C_data, F_data=JHU_F_data, R_data=JHU_R_data, mu_IFR=0.01, fit_par=NULL, intervention){
if(is.null(fit_par)==TRUE){
fit_par=fit_to_SEIR(region, C_data, F_data, R_data, mu_IFR, pop, beta_type="time-dep", intervention=intervention)
}
tau_mu_CFR=fit_tau_mu_CFR(region, C_data, F_data)
tau=tau_mu_CFR[1]
mu_CFR=tau_mu_CFR[2]
names=c("beta_b", "beta_a", "rho", "a", "kappa", "eta", "mu_E", "mu_2")
fit_par=c(fit_par[1], fit_par[2], rho=1-mu_CFR, a=1, kappa=1/1.2, eta=1/8, mu_E=1/4, mu_2=1/5)
names(fit_par)=names
cases_C=as.integer(C_data[5:nrow(C_data), region])
cases_C=cases_C[!is.na(cases_C)]
start=min(which(cases_C>0, arr.ind=TRUE))
times=c(start:length(cases_C))
phi=phi_vs_time(region, C_data, F_data, mu_CFR=mu_CFR)
phi$times=phi$times-tau
fit=lm(ratios~poly(times, 4, raw=TRUE), data=phi)
Rt_list=c()
times2=c()
with(as.list(fit_par), {
for(t in c(times[1]:max(times)-ceiling(1/kappa))){
t2=t+1/kappa
if(t2>=phi$times[1]){
newdata=data.frame(times=as.numeric(t2))
phi2=as.numeric(predict(fit, newdata=newdata))
}
else{
phi2=mean(phi$ratios)
}
if(t2<intervention){
Rt=beta_b/kappa+(1/phi2)*beta_b/mu_2+(1-phi2)*beta_b/(mu_2+eta)
Rt_list=append(Rt_list, Rt)
}else{
Rt=beta_a/kappa+(1/phi2)*beta_a/mu_2+(1-phi2)*beta_a/(mu_2+eta)
Rt_list=append(Rt_list, Rt)
}
times2=c(times[1]:max(times)-ceiling(1/kappa))
}
Rt_df=data.frame(times2, Rt_list)
return(Rt_df)
})
}
plot_Rt_model=function(region, C_data=JHU_C_data, F_data=JHU_F_data, R_data=JHU_R_data, mu_IFR=0.01, fit_par=NULL, intervention){
region_name=regions(C_data)[region]
Rt_df=Rt_model(region, C_data, F_data, R_data, mu_IFR, fit_par, intervention)
plot=ggplot(data=Rt_df, aes(x=times2, y=Rt_list))+geom_line()+labs(title=region_name)
print(plot)
}
fit_all_params_simultaneous(121)
region=121
C_data=JHU_C_data
F_data=JHU_F_data
#format case data for a given region
cases_C=as.integer(C_data[5:nrow(C_data), region])
cases_C=cases_C[!is.na(cases_C)]
#format fatality data for a given region
cases_F=as.integer(F_data[5:nrow(F_data), region])
cases_F=cases_F[!is.na(cases_F)]
par=c(r=2, p=1, alpha=1, K=cases_C[length(cases_C)], tau=20, mu_CFR=0.05)
#performs the fit
fit=optim(par=par, fn=ssq_all_params_simultaneous, cases_C=cases_C, cases_F=cases_F, control=list(parscale=c(1,1,1,10^floor(log10(cases_C[length(cases_C)])), 1, 0.5)))
#parameters
r=par[1]
p=par[2]
alpha=par[3]
K=par[4]
mu_CFR=par[5]
tau=par[6]
start_C=min(which(cases_C>0, arr.ind=TRUE))
cases_C=c(cases_C[start_C:length(cases_C)])
start_F=min(which(cases_F>0, arr.ind=TRUE))
cases_F=c(cases_F[start_F:length(cases_F)])
#times=seq(0, length(cases_C), 0.1)
t=c(1:length(cases_C))
#times=sort(union(times, t))
# df=data.frame(t, cases_C)
init=c(C=cases_C[1], F_=cases_F[1])
#solves the ODE for times in t
out_1=ode(y=init, times=t, func=C_F_rates, parms=par)
init
#define the ODE system for fitting parameters to F and C as well as tau and mu_CFR
C_F_rates=function(t, x, par){
#parameters
r=par[1]
p=par[2]
alpha=par[3]
K=par[4]
mu_CFR=par[5]
tau=par[6]
r_tilde=r*(1-p)/(mu_CFR)
K_tilde=mu_CFR*K
#F is total fatalities
dF_=r_tilde*F_^p*(1-(F_/K_tilde)^alpha)
dC=r*C^p*(1-(C/K)^alpha)
return(list(dF_, dC))
}
#solves the ODE for times in t
out_1=ode(y=init, times=t, func=C_F_rates, parms=par)
#times=sort(union(times, t))
# df=data.frame(t, cases_C)
init=c(C=cases_C[1], F_=cases_F[1])
#solves the ODE for times in t
out_1=ode(y=init, times=t, func=C_F_rates, parms=par)
#define the ODE system for fitting parameters to F and C as well as tau and mu_CFR
C_F_rates=function(t, x, par){
with(as.list(c(x, par)), {
#parameters
r=par[1]
p=par[2]
alpha=par[3]
K=par[4]
mu_CFR=par[5]
tau=par[6]
r_tilde=r*(1-p)/(mu_CFR)
K_tilde=mu_CFR*K
#F is total fatalities
dF_=r_tilde*F_^p*(1-(F_/K_tilde)^alpha)
dC=r*C^p*(1-(C/K)^alpha)
list(dF_, dC)
})
}
#solves the ODE for times in t
out_1=ode(y=init, times=t, func=C_F_rates, parms=par)
#for fitting tau, mu_CFR, and r, p, alpha, k all at once
#par is a vector the guesses for the parameters to be fitted
#F_parest is the guesses for parameters for the fatality data, returned from fit_param_F()
ssq_all_params_simultaneous=function(par, cases_C, cases_F){
#parameters
r=par[1]
p=par[2]
alpha=par[3]
K=par[4]
mu_CFR=par[5]
tau=par[6]
start_C=min(which(cases_C>0, arr.ind=TRUE))
cases_C=c(cases_C[start_C:length(cases_C)])
start_F=min(which(cases_F>0, arr.ind=TRUE))
cases_F=c(cases_F[start_F:length(cases_F)])
#times=seq(0, length(cases_C), 0.1)
t=c(1:length(cases_C))
#times=sort(union(times, t))
# df=data.frame(t, cases_C)
init=c(C=cases_C[1], F_=cases_F[1])
#solves the ODE for times in t
out_1=ode(y=init, times=t, func=C_F_rates, parms=par)
cases_C_1=out_1[,"C"]
cases_F_1=out_1[,"F_"]
#shift times for cumulative cases by tau
times_shifted=t+tau
out_2=ode(x=init, times=times_shifted, func=C_F_rates, parms=par)
cases_C_2=out_2[,"C"]
#separate values from before and after the first death (since ODE solver only starts at beginning of outbreak)
y=c()
times2=c()
for(x in times_shifted){
if(x<start_F){
y=append(y, 0)
}
else{
times2=append(times2, x)
}
}
#setting up the times to generate the fatality curve after the outbreak starts
times2=times2-start+1
#we add value 1 at the beginning so the curve starts at the start of the deaths with the proper initial value
times2=append(times2, 1, after=0)
#generates the estimates at the required times
F_out=ode(y=init, times=times2, func=C_F_rates, parms=par)
F_df=data.frame(F_out)
#changes times_2 back to the correct values
times2=times2+start-1
#relabels the times again so they are the same as the original
colnames(F_df)=c("t", "cases_F_2")
#removes the extra "1" we added to the times
F_df=F_df[-1,]
#builds the dataframe, adding the initial zeroes to the generated values
cases_F_2=c(y, F_df$cases_F_2)
#new_df=data.frame(times_shifted, y)
#finds the absolute squared distance between the death and cases data curves plus the distance for the two curves after the shift
ssqr=sum(sqrt((cases_C_1-cases_C)^2)/mean(cases_C))+sum(sqrt((cases_F_1-cases_F)^2)/mean(cases_F))+sum((cases_F_2-cases_C_2*mu_CFR)^2)
return(ssqr)
}
#solves the ODE for times in t
out_1=ode(x=init, times=t, func=C_F_rates, parms=par)
#define the ODE system for fitting parameters to F and C as well as tau and mu_CFR
C_F_rates=function(t, y, par){
with(as.list(c(y, par)), {
#parameters
r=par[1]
p=par[2]
alpha=par[3]
K=par[4]
mu_CFR=par[5]
tau=par[6]
r_tilde=r*(1-p)/(mu_CFR)
K_tilde=mu_CFR*K
#F is total fatalities
dF_=r_tilde*F_^p*(1-(F_/K_tilde)^alpha)
dC=r*C^p*(1-(C/K)^alpha)
list(dF_, dC)
})
}
#solves the ODE for times in t
out_1=ode(y=init, times=t, func=C_F_rates, parms=par)
init
C_F_rates(3, c(1, 2), par)
C_F_rates(3, c(C=11, F_=2), par)
out_1=ode(y=c(C=11, F_=2), times=t, func=C_F_rates, parms=par)
#define the ODE system for fitting parameters to F and C as well as tau and mu_CFR
C_F_rates=function(t, y, par){
with(as.list(c(y, par)), {
#parameters
r=par[1]
p=par[2]
alpha=par[3]
K=par[4]
mu_CFR=par[5]
tau=par[6]
r_tilde=r*(1-p)/(mu_CFR)
K_tilde=mu_CFR*K
#F is total fatalities
dF_=r_tilde*F_^p*(1-(F_/K_tilde)^alpha)
dC=r*C^p*(1-(C/K)^alpha)
list(c(dF_, dC))
})
}
out_1=ode(y=c(C=11, F_=2), times=t, func=C_F_rates, parms=par)
fit_all_params_simultaneous(121)
#define the ODE system for fitting parameters to F and C as well as tau and mu_CFR
C_F_rates=function(t, x, par){
with(as.list(c(x, par)), {
#parameters
r=par[1]
p=par[2]
alpha=par[3]
K=par[4]
mu_CFR=par[5]
tau=par[6]
r_tilde=r*(1-p)/(mu_CFR)
K_tilde=mu_CFR*K
#F is total fatalities
dF_=r_tilde*F_^p*(1-(F_/K_tilde)^alpha)
dC=r*C^p*(1-(C/K)^alpha)
list(c(dF_, dC))
})
}
#for fitting tau, mu_CFR, and r, p, alpha, k all at once
#par is a vector the guesses for the parameters to be fitted
#F_parest is the guesses for parameters for the fatality data, returned from fit_param_F()
ssq_all_params_simultaneous=function(par, cases_C, cases_F){
#parameters
r=par[1]
p=par[2]
alpha=par[3]
K=par[4]
mu_CFR=par[5]
tau=par[6]
start_C=min(which(cases_C>0, arr.ind=TRUE))
cases_C=c(cases_C[start_C:length(cases_C)])
start_F=min(which(cases_F>0, arr.ind=TRUE))
cases_F=c(cases_F[start_F:length(cases_F)])
#times=seq(0, length(cases_C), 0.1)
t=c(1:length(cases_C))
#times=sort(union(times, t))
# df=data.frame(t, cases_C)
init=c(C=cases_C[1], F_=cases_F[1])
#solves the ODE for times in t
out_1=ode(y=init, times=t, func=C_F_rates, parms=par)
cases_C_1=out_1[,"C"]
cases_F_1=out_1[,"F_"]
#shift times for cumulative cases by tau
times_shifted=t+tau
out_2=ode(y=init, times=times_shifted, func=C_F_rates, parms=par)
cases_C_2=out_2[,"C"]
#separate values from before and after the first death (since ODE solver only starts at beginning of outbreak)
y=c()
times2=c()
for(x in times_shifted){
if(x<start_F){
y=append(y, 0)
}
else{
times2=append(times2, x)
}
}
#setting up the times to generate the fatality curve after the outbreak starts
times2=times2-start+1
#we add value 1 at the beginning so the curve starts at the start of the deaths with the proper initial value
times2=append(times2, 1, after=0)
#generates the estimates at the required times
F_out=ode(y=init, times=times2, func=C_F_rates, parms=par)
F_df=data.frame(F_out)
#changes times_2 back to the correct values
times2=times2+start-1
#relabels the times again so they are the same as the original
colnames(F_df)=c("t", "cases_F_2")
#removes the extra "1" we added to the times
F_df=F_df[-1,]
#builds the dataframe, adding the initial zeroes to the generated values
cases_F_2=c(y, F_df$cases_F_2)
#new_df=data.frame(times_shifted, y)
#finds the absolute squared distance between the death and cases data curves plus the distance for the two curves after the shift
ssqr=sum(sqrt((cases_C_1-cases_C)^2)/mean(cases_C))+sum(sqrt((cases_F_1-cases_F)^2)/mean(cases_F))+sum((cases_F_2-cases_C_2*mu_CFR)^2)
return(ssqr)
}
fit_all_params_simultaneous(121)
#solves the ODE for times in t
out_1=ode(y=init, times=t, func=C_F_rates, parms=par)
cases_C_1=out_1[,"C"]
cases_F_1=out_1[,"F_"]
#shift times for cumulative cases by tau
times_shifted=t+tau
out_2=ode(y=init, times=times_shifted, func=C_F_rates, parms=par)
cases_C_2=out_2[,"C"]
#separate values from before and after the first death (since ODE solver only starts at beginning of outbreak)
y=c()
times2=c()
for(x in times_shifted){
if(x<start_F){
y=append(y, 0)
}
else{
times2=append(times2, x)
}
}
times2
start
#for fitting tau, mu_CFR, and r, p, alpha, k all at once
#par is a vector the guesses for the parameters to be fitted
#F_parest is the guesses for parameters for the fatality data, returned from fit_param_F()
ssq_all_params_simultaneous=function(par, cases_C, cases_F){
#parameters
r=par[1]
p=par[2]
alpha=par[3]
K=par[4]
mu_CFR=par[5]
tau=par[6]
start_C=min(which(cases_C>0, arr.ind=TRUE))
cases_C=c(cases_C[start_C:length(cases_C)])
start_F=min(which(cases_F>0, arr.ind=TRUE))
cases_F=c(cases_F[start_F:length(cases_F)])
#times=seq(0, length(cases_C), 0.1)
t=c(1:length(cases_C))
#times=sort(union(times, t))
# df=data.frame(t, cases_C)
init=c(C=cases_C[1], F_=cases_F[1])
#solves the ODE for times in t
out_1=ode(y=init, times=t, func=C_F_rates, parms=par)
cases_C_1=out_1[,"C"]
cases_F_1=out_1[,"F_"]
#shift times for cumulative cases by tau
times_shifted=t+tau
out_2=ode(y=init, times=times_shifted, func=C_F_rates, parms=par)
cases_C_2=out_2[,"C"]
#separate values from before and after the first death (since ODE solver only starts at beginning of outbreak)
y=c()
times2=c()
for(x in times_shifted){
if(x<start_F){
y=append(y, 0)
}
else{
times2=append(times2, x)
}
}
#setting up the times to generate the fatality curve after the outbreak starts
times2=times2-start_F+1
#we add value 1 at the beginning so the curve starts at the start of the deaths with the proper initial value
times2=append(times2, 1, after=0)
#generates the estimates at the required times
F_out=ode(y=init, times=times2, func=C_F_rates, parms=par)
F_df=data.frame(F_out)
#changes times_2 back to the correct values
times2=times2+start_F-1
#relabels the times again so they are the same as the original
colnames(F_df)=c("t", "cases_F_2")
#removes the extra "1" we added to the times
F_df=F_df[-1,]
#builds the dataframe, adding the initial zeroes to the generated values
cases_F_2=c(y, F_df$cases_F_2)
#new_df=data.frame(times_shifted, y)
#finds the absolute squared distance between the death and cases data curves plus the distance for the two curves after the shift
ssqr=sum(sqrt((cases_C_1-cases_C)^2)/mean(cases_C))+sum(sqrt((cases_F_1-cases_F)^2)/mean(cases_F))+sum((cases_F_2-cases_C_2*mu_CFR)^2)
return(ssqr)
}
fit_all_params_simultaneous(121)
