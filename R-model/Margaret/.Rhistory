p=par[2]
alpha=1
K=10^8
out=ode(y=init, times=t, func=rate, parms=par)
outdf=data.frame(out)
colnames(outdf)=c("t", "pred")
ssqr=ssq(outdf$pred, df$NScases)
return(ssqr)
}
ssqpar(par)
par=c(r=1, p=2)
fitval=nls.lm(par=par, fn=ssqpar)
ssqpar=function(par){
r=par[1]
p=par[2]
alpha=1
K=10^8
out=ode(y=init, times=t, func=rate, parms=par)
outdf=data.frame(out)
colnames(outdf)=c("t", "pred")
ssqr=outdf$pred-df$NScases
return(ssqr)
}
par=c(r=1, p=2)
fitval=nls.lm(par=par, fn=ssqpar)
ssqpar(par)
par=c(r=0.5, p=0.5)
fitval=nls.lm(par=par, fn=ssqpar)
summary(fitval)
#solODE=(y=21, x, func=ODEfun, )
library("ggplot2")
library(deSolve)
library(hydroGOF)
library(minpack.lm)
library(reshape2)
NScases=c(21,28,41,51,68,73,90,110,122,127,147,170,193,207,236,262,293,310,342,373,407,428,445,474,517,547,579)
NSnewcases=c(7,13,10,17,5,17,20,12,5,20,23,23,14,29,26,31,17,32,31,34,21,17,29,43,30,32)
t=c(1:length(NScases))
df=data.frame(t, NScases)
rate=function(t, C, par){
#constants
r=par[1]
p=par[2]
alpha=1
K=10^8
#c is total cases
dC=r*(C^p)*(1-(C/K)^alpha)
return(list(dC))
}
init=c(NScases[1])
par=c(r=2, p=2, alpha=1, K=10^8)
out=ode(y=init, times=t, func=rate, parms=par)
outdf=data.frame(out)
colnames(outdf)=c("t", "pred")
ssqpar=function(par){
r=par[1]
p=par[2]
alpha=1
K=10^8
out=ode(y=init, times=t, func=rate, parms=par)
outdf=data.frame(out)
colnames(outdf)=c("t", "pred")
ssqr=outdf$pred-df$NScases
return(ssqr)
}
par=c(r=0.5, p=0.5)
fitval=nls.lm(par=par, fn=ssqpar)
summary(fitval)
#load libraries
library(deSolve)
library(minpack.lm)
#load and format data
NScases=c(21,28,41,51,68,73,90,110,122,127,147,170,193,207,236,262,293,310,342,373,407,428,445,474,517,547,579)
NSnewcases=c(7,13,10,17,5,17,20,12,5,20,23,23,14,29,26,31,17,32,31,34,21,17,29,43,30,32)
t=c(1:length(NScases))
df=data.frame(t, NScases)
init=c(NScases[1])
#define the ODE
rate=function(t, C, par){
#constants
r=par[1]
p=par[2]
alpha=1
K=10^8
#c is total cases
dC=r*(C^p)*(1-(C/K)^alpha)
return(list(dC))
}
#function that calculates residuals (to be minimized)
ssqpar=function(par){
r=par[1]
p=par[2]
alpha=1
K=10^8
out=ode(y=init, times=t, func=rate, parms=par)
outdf=data.frame(out)
colnames(outdf)=c("t", "pred")
ssqr=outdf$pred-df$NScases
return(ssqr)
}
#starting guess for parameters
par=c(r=0.5, p=0.5)
#modified Levenberg-Marquardt algorithm to minimize residuals
fitval=nls.lm(par=par, fn=ssqpar)
summary(fitval)
#load libraries
library(deSolve)
library(minpack.lm)
#load and format data
NScases=c(21,28,41,51,68,73,90,110,122,127,147,170,193,207,236,262,293,310,342,373,407,428,445,474,517,547,579)
NSnewcases=c(7,13,10,17,5,17,20,12,5,20,23,23,14,29,26,31,17,32,31,34,21,17,29,43,30,32)
t=c(1:length(NScases))
df=data.frame(t, NScases)
init=c(NScases[1])
#define the ODE
rate=function(t, C, par){
#parameters (alpha and K set)
r=par[1]
p=par[2]
alpha=1
K=10^8
#c is total cases
dC=r*(C^p)*(1-(C/K)^alpha)
return(list(dC))
}
#function that calculates residuals (to be minimized)
ssqpar=function(par){
r=par[1]
p=par[2]
alpha=1
K=10^8
#solves the ODE for times in t
out=ode(y=init, times=t, func=rate, parms=par)
#formats predicted data from ODE
outdf=data.frame(out)
colnames(outdf)=c("t", "pred")
#calculates residuals from ODE
ssqr=outdf$pred-df$NScases
return(ssqr)
}
#starting guess for parameters
par=c(r=0.5, p=0.5)
#modified Levenberg-Marquardt algorithm to minimize residuals
fitval=nls.lm(par=par, fn=ssqpar)
summary(fitval)
#load libraries
library(deSolve)
library(minpack.lm)
#load and format data
NScases=c(21,28,41,51,68,73,90,110,122,127,147,170,193,207,236,262,293,310,342,373,407,428,445,474,517,547,579)
#load libraries
library(deSolve)
library(minpack.lm)
#load and format data
NScases=c(21,28,41,51,68,73,90,110,122,127,147,170,193,207,236,262,293,310,342,373,407,428,445,474,517,547,579)
NSnewcases=c(7,13,10,17,5,17,20,12,5,20,23,23,14,29,26,31,17,32,31,34,21,17,29,43,30,32)
t=c(1:length(NScases))
df=data.frame(t, NScases)
init=c(NScases[1])
#define the ODE
rate=function(t, C, par){
#parameters (alpha and K set)
r=par[1]
p=par[2]
alpha=1
K=10^8
#c is total cases
dC=r*(C^p)*(1-(C/K)^alpha)
return(list(dC))
}
#function that calculates residuals (to be minimized)
ssqpar=function(par){
r=par[1]
p=par[2]
alpha=1
K=10^8
#solves the ODE for times in t
out=ode(y=init, times=t, func=rate, parms=par)
#formats predicted data from ODE
outdf=data.frame(out)
colnames(outdf)=c("t", "pred")
#calculates residuals from ODE
ssqr=outdf$pred-df$NScases
return(ssqr)
}
#starting guess for parameters
par=c(r=0.5, p=0.5)
#modified Levenberg-Marquardt algorithm to minimize residuals
fitval=nls.lm(par=par, fn=ssqpar)
summary(fitval)
#starting guess for parameters
par=c(r=2, p=0.5)
#modified Levenberg-Marquardt algorithm to minimize residuals
fitval=nls.lm(par=par, fn=ssqpar)
summary(fitval)
#starting guess for parameters
par=c(r=1.94, p=0.45)
#modified Levenberg-Marquardt algorithm to minimize residuals
fitval=nls.lm(par=par, fn=ssqpar)
summary(fitval)
#load libraries
library(deSolve)
library(minpack.lm)
#load and format data
NScases=c(21,28,41,51,68,73,90,110,122,127,147,170,193,207,236,262,293,310,342,373,407,428,445,474,517,547,579)
NSnewcases=c(7,13,10,17,5,17,20,12,5,20,23,23,14,29,26,31,17,32,31,34,21,17,29,43,30,32)
t=c(1:length(NScases))
df=data.frame(t, NScases)
init=c(NScases[1])
#define the ODE
rate=function(t, C, par){
#parameters (alpha and K set)
r=par[1]
p=par[2]
alpha=1
K=10^8
#c is total cases
dC=r*(C^p)*(1-(C/K)^alpha)
return(list(dC))
}
#function that calculates residuals (to be minimized)
ssqpar=function(par){
r=par[1]
p=par[2]
alpha=1
K=10^8
#solves the ODE for times in t
out=ode(y=init, times=t, func=rate, parms=par)
#formats predicted data from ODE
outdf=data.frame(out)
colnames(outdf)=c("t", "pred")
#calculates residuals from ODE
ssqr=outdf$pred-df$NScases
return(ssqr)
}
#starting guess for parameters
par=c(r=1.94, p=0.45)
#modified Levenberg-Marquardt algorithm to minimize residuals
fitval=nls.lm(par=par, fn=ssqpar)
summary(fitval)
rates<-c("c*(beta_p*I_p+beta_m*I_m+beta_A*A)*S/(S+E+B+A+I_p+I_m+J+H+F+Q_m+Q_J+R)",
"gamma",
"mu_E*E",
"(1-phi)*mu_1*I_p",
"mu_A*A",
"phi*mu_1*I_p",
"theta*mu_2*I_m",
"(1-theta)*mu_2*I_m",
"lambda*I_m",
"lambda*J",
"mu_2*Q_m",
"mu_J*J",
"mu_J*Q_J",
"rho*mu_H*H",
"(1-rho)*mu_H*H",
"kappa*E",
"kappa*A",
"kappa*I_p")
length(rates)
library("ggplot2")
#set this to your working directory
setwd("C:/Users/mjiho/ac-disease-modelling/R-model/Margaret/")
#source file
source("SEIAR_Teismann.R")
#read in parameter values
paramset<-read.csv("params_Teismann.csv")
#initial states
S0<-c(S=1000, E=0, B=0, A=0, I_p=20, I_m=0, J=0, H=0, F=0, Q_m=0, Q_J=0, R=0)
#choose parameter set
param=paramset[1, 2:17]
#control reproduction number, when control measures are in place
Rc=with(param, (mu_E/(mu_E+kappa))*((beta_p/(mu_1+kappa))+(phi*mu_1+beta_m)/((mu_1+kappa)*(mu_2+lambda))+((1-phi)*mu_1*beta_A)/((mu_1+kappa)*(mu_A+lambda))))
Rc
#final time for SSA
tf<-60
#output times for ODE solver
times<-seq(0, tf, by=0.01)
#"runs" is number of simulations
A=repsim(S0, rates, nu, param=param, tf=360, simName, runs=20)
data.fr''
data.frame()
data.frame(NULL)
library("ggplot2")
#set this to your working directory
setwd("C:/Users/mjiho/ac-disease-modelling/R-model/Margaret/")
#source file
source("SEIAR_Teismann.R")
#read in parameter values
paramset<-read.csv("params_Teismann.csv")
#initial states
S0<-c(S=1000, E=0, B=0, A=0, I_p=20, I_m=0, J=0, H=0, F=0, Q_m=0, Q_J=0, R=0)
#choose parameter set
param=paramset[1, 2:17]
#control reproduction number, when control measures are in place
Rc=with(param, (mu_E/(mu_E+kappa))*((beta_p/(mu_1+kappa))+(phi*mu_1+beta_m)/((mu_1+kappa)*(mu_2+lambda))+((1-phi)*mu_1*beta_A)/((mu_1+kappa)*(mu_A+lambda))))
Rc
#final time for SSA
tf<-60
#output times for ODE solver
times<-seq(0, tf, by=0.01)
#"runs" is number of simulations
A=repsim(S0, rates, nu, param=param, tf=360, simName, runs=20)
#initial states
S0<-c(S=1000, E=0, B=0, A=0, I_p=20, I_m=0, J=0, H=0, F=0, Q_m=0, Q_J=0, R=0)
ssa(x0=S0,
a=rates, nu, parms=param, tf,
method=method, simName,
verbose=FALSE, ignoreNegativeState = TRUE)
ssa(x0=S0,
a=rates, nu, parms=param, tf,
method=ssa.d(), simName,
verbose=FALSE, ignoreNegativeState = TRUE)
ssa(x0=S0,
a=rates, nu, parms=param, tf,
method=ssa.etl(), simName,
verbose=FALSE, ignoreNegativeState = TRUE)
ssa(x0=S0,
a=rates, nu, parms=param, tf,
method=ssa.btl(), simName,
verbose=FALSE, ignoreNegativeState = TRUE)
ssa(x0=S0,
a=rates, nu, parms=param, tf,
method=ssa.otl(), simName,
verbose=FALSE, ignoreNegativeState = TRUE)
View(nu)
View(param)
library("ggplot2")
#set this to your working directory
setwd("C:/Users/mjiho/ac-disease-modelling/R-model/Margaret/")
#source file
source("SEIAR_Teismann2.R")
#read in parameter values
paramset<-read.csv("params_Teismann.csv")
#initial states
S0<-c(S=1000, E=0, B=0, A=0, I_p=20, I_m=0, J=0, H=0, F=0, Q_m=0, Q_J=0, R=0)
#choose parameter set
param=paramset[1, 2:17]
#control reproduction number, when control measures are in place
Rc=with(param, (mu_E/(mu_E+kappa))*((beta_p/(mu_1+kappa))+(phi*mu_1+beta_m)/((mu_1+kappa)*(mu_2+lambda))+((1-phi)*mu_1*beta_A)/((mu_1+kappa)*(mu_A+lambda))))
Rc
#final time for SSA
tf<-60
#output times for ODE solver
times<-seq(0, tf, by=0.01)
#"runs" is number of simulations
A=repsim(S0, rates, nu, param=param, tf=360, simName, runs=20)
library("ggplot2")
#set this to your working directory
setwd("C:/Users/mjiho/ac-disease-modelling/R-model/Margaret/")
#source file
source("SEIAR_Teismann2.R")
#read in parameter values
paramset<-read.csv("params_Teismann.csv")
#initial states
S0<-c(S=800, E=0, B=0, A=0, I_p=20, I_m=0, J=0, H=0, F=0, Q_m=0, Q_J=0, R=0)
#choose parameter sets
param=paramset[1, 2:16]
#final time for SSA
tf<-60
#output times for ODE solver
times<-seq(0, tf, by=0.01)
#number of simulations
A=repsim(S0, rates, nu, param=param, tf=360, simName, runs=20)
param
library("ggplot2")
#set this to your working directory
setwd("C:/Users/mjiho/ac-disease-modelling/R-model/Margaret/")
#source file
source("SEIAR_Teismann2.R")
#read in parameter values
paramset<-read.csv("params_Teismann.csv")
#initial states
S0<-c(S=800, E=0, B=0, A=0, I_p=20, I_m=0, J=0, H=0, F=0, Q_m=0, Q_J=0, R=0)
#choose parameter sets
param=paramset[1, 2:16]
#final time for SSA
tf<-60
#output times for ODE solver
times<-seq(0, tf, by=0.01)
#number of simulations
A=repsim(S0, rates, nu, param=param, tf=360, simName, runs=20)
#plot E for every simulation
sampleruns<-ggplot(A, aes(x=t, y=Q_m))+geom_line(aes(color=run))
print(sampleruns)
#source file
source("SEIAR_Teismann2.R")
#read in parameter values
paramset<-read.csv("params_Teismann.csv")
#initial states
S0<-c(S=800, E=0, B=0, A=0, I_p=20, I_m=0, J=0, H=0, F=0, Q_m=0, Q_J=0, R=0)
#choose parameter sets
param=as.list(paramset[1, 2:16])
#final time for SSA
tf<-60
#output times for ODE solver
times<-seq(0, tf, by=0.01)
#number of simulations
A=repsim(S0, rates, nu, param=param, tf=360, simName, runs=20)
library("ggplot2")
#set this to your working directory
setwd("C:/Users/mjiho/ac-disease-modelling/R-model/Margaret/")
#source file
source("SEIAR_Teismann2.R")
#read in parameter values
paramset<-read.csv("params_Teismann.csv")
#initial states
S0<-c(S=1000, E=0, B=0, A=0, I_p=20, I_m=0, J=0, H=0, F=0, Q_m=0, Q_J=0, R=0)
#choose parameter set
param=paramset[1, 2:17]
#control reproduction number, when control measures are in place
Rc=with(param, (mu_E/(mu_E+kappa))*((beta_p/(mu_1+kappa))+(phi*mu_1+beta_m)/((mu_1+kappa)*(mu_2+lambda))+((1-phi)*mu_1*beta_A)/((mu_1+kappa)*(mu_A+lambda))))
Rc
#final time for SSA
tf<-60
#output times for ODE solver
times<-seq(0, tf, by=0.01)
#"runs" is number of simulations
A=repsim(S0, rates, nu, param=param, tf=360, simName, runs=20)
#plot E for every simulation
sampleruns<-ggplot(A, aes(x=t, y=R))+geom_line(aes(color=run))
print(sampleruns)
#plot L, I, A for one simulation
B=pluckrun(A, 3)
singlerun<-ggplot(B, aes(x=t, y=values))+geom_line(aes(color=ind))
print(singlerun)
res_ode<-ode(y=S0, times, func=rhs, param)
plot(res_ode[,1], res_ode[,'S'], col='red')
library("ggplot2")
#set working directory (change user name)
setwd("C:/Users/mjiho/ac-disease-modelling/R-model/Watmough-SLIAR-model/")
source("R/SLIAR-SSA.R")
paramset <- read.csv("data/parameter-sets.csv")
Ro = with(paramset, beta*(epsilon/kappa + p/alpha + (1-p)*delta/eta) )
# use the second parameter set  (Diamond Princess paper)
param = paramset[1,2:9]
# Initial state vector for ssa
# A = 1 for the initial 'invasion'
# I = 20, A = 40 for the 'switch on distancing' scenario
S0  <- c(S=1000, L=0, I = 1, A = 0, R = 0)
# final time for SSA
tf <- 60
# output times for ode solver
times <- seq(0, tf, by=0.01)
# 20 simulations
A = repsim(S0,rates,nu,param=param,tf=360,simName,runs=20)
# plot R for every sim
sampleruns <- ggplot(A,aes(x=t,y=R))+geom_line(aes(color = run))
paramset <- read.csv("data/parameter-sets.csv")
Ro = with(paramset, beta*(epsilon/kappa + p/alpha + (1-p)*delta/eta) )
# use the second parameter set  (Diamond Princess paper)
param = paramset[2,2:9]
# Initial state vector for ssa
# A = 1 for the initial 'invasion'
# I = 20, A = 40 for the 'switch on distancing' scenario
S0  <- c(S=1000, L=0, I = 1, A = 0, R = 0)
# final time for SSA
tf <- 60
# output times for ode solver
times <- seq(0, tf, by=0.01)
# 20 simulations
A = repsim(S0,rates,nu,param=param,tf=360,simName,runs=20)
paramset
library("ggplot2")
#set this to your working directory
setwd("C:/Users/mjiho/ac-disease-modelling/R-model/Margaret/")
#source file
source("SEIAR_Teismann2.R")
#read in parameter values
paramset<-read.csv("params_Teismann.csv")
#source file
source("SEIAR_Teismann.R")
#read in parameter values
paramset<-read.csv("params_Teismann.csv")
#initial states
S0<-c(S=1000, E=0, B=0, A=0, I_p=20, I_m=0, J=0, H=0, F=0, Q_m=0, Q_J=0, R=0)
#choose parameter set
param=paramset[1, 2:17]
paramset
#choose parameter set
param=as.numeric(paramset[1, 2:17])
param
#control reproduction number, when control measures are in place
Rc=with(param, (mu_E/(mu_E+kappa))*((beta_p/(mu_1+kappa))+(phi*mu_1+beta_m)/((mu_1+kappa)*(mu_2+lambda))+((1-phi)*mu_1*beta_A)/((mu_1+kappa)*(mu_A+lambda))))
#choose parameter set
param=paramset[1, 2:17]
#control reproduction number, when control measures are in place
Rc=with(param, (mu_E/(mu_E+kappa))*((beta_p/(mu_1+kappa))+(phi*mu_1+beta_m)/((mu_1+kappa)*(mu_2+lambda))+((1-phi)*mu_1*beta_A)/((mu_1+kappa)*(mu_A+lambda))))
Rc
#final time for SSA
tf<-60
#output times for ODE solver
times<-seq(0, tf, by=0.01)
#"runs" is number of simulations
A=repsim(S0, rates, nu, param=param, tf=360, simName, runs=20)
#read in parameter values
paramset<-read.csv("params_Teismann.csv")
#initial states
S0<-c(S=1000, E=0, B=0, A=0, I_p=20, I_m=0, J=0, H=0, F=0, Q_m=0, Q_J=0, R=0)
#choose parameter set
param=paramset[1, 2:17]
#control reproduction number, when control measures are in place
Rc=with(param, (mu_E/(mu_E+kappa))*((beta_p/(mu_1+kappa))+(phi*mu_1+beta_m)/((mu_1+kappa)*(mu_2+lambda))+((1-phi)*mu_1*beta_A)/((mu_1+kappa)*(mu_A+lambda))))
Rc
#final time for SSA
tf<-60
#output times for ODE solver
times<-seq(0, tf, by=0.01)
#"runs" is number of simulations
A=repsim(S0, rates, nu, param=param, tf=360, simName, runs=20)
#plot E for every simulation
sampleruns<-ggplot(A, aes(x=t, y=R))+geom_line(aes(color=run))
print(sampleruns)
